# Tauri Release Workflow with Oasis Update Server Integration
#
# This workflow builds, signs, and releases the Tauri app for all platforms,
# uploads artifacts to Cloudflare R2, and registers the release with Oasis.
#
# Required Secrets:
# -----------------
# Apple Code Signing (macOS only):
#   - APPLE_CERTIFICATE: Base64-encoded .p12 certificate
#   - APPLE_CERTIFICATE_PASSWORD: Password for the .p12 certificate
#   - APPLE_SIGNING_IDENTITY: Certificate identity (e.g., "Developer ID Application: Your Name (TEAM_ID)")
#
# Apple Notarization (macOS only):
#   - APPLE_ID: Apple ID email for notarization
#   - APPLE_PASSWORD: App-specific password for notarization
#   - APPLE_TEAM_ID: Apple Developer Team ID
#
# Tauri Update Signing:
#   - TAURI_SIGNING_PRIVATE_KEY: Private key for signing update bundles
#   - TAURI_SIGNING_PRIVATE_KEY_PASSWORD: Password for the signing key (if set)
#
# Cloudflare R2 Storage:
#   - CLOUDFLARE_ACCOUNT_ID: Cloudflare account ID
#   - CLOUDFLARE_R2_ACCESS_KEY_ID: R2 API access key ID
#   - CLOUDFLARE_R2_SECRET_ACCESS_KEY: R2 API secret access key
#   - R2_BUCKET_NAME: Name of the R2 bucket for uploads
#   - R2_PUBLIC_URL: Public URL base for R2 bucket (e.g., https://releases.example.com)
#
# Oasis Update Server:
#   - OASIS_SERVER_URL: Base URL of Oasis server (e.g., https://updates.example.com)
#   - OASIS_CI_KEY: API key for Oasis CI endpoints

name: Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      dry_run:
        description: "Dry run (skip uploads and registration)"
        required: false
        default: false
        type: boolean

env:
  APP_SLUG: rigid
  CARGO_INCREMENTAL: 0

jobs:
  # ===========================================================================
  # Build job - builds for all platforms in parallel
  # ===========================================================================
  build:
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: macos-latest
            target: aarch64-apple-darwin
            arch: aarch64
            os: darwin
            ffmpeg_target: macos-arm64
            # app bundle generates .app.tar.gz for updater, dmg for installer
            bundle_targets: app,dmg
          - platform: macos-latest
            target: x86_64-apple-darwin
            arch: x86_64
            os: darwin
            ffmpeg_target: macos-x64
            bundle_targets: app,dmg
          - platform: ubuntu-22.04
            target: x86_64-unknown-linux-gnu
            arch: x86_64
            os: linux
            ffmpeg_target: linux-x64
            # appimage for updater (manually tarred), deb for installer
            bundle_targets: appimage,deb
          - platform: windows-latest
            target: x86_64-pc-windows-msvc
            arch: x86_64
            os: windows
            ffmpeg_target: windows
            # nsis generates both installer (.exe) and updater (.nsis.zip)
            bundle_targets: nsis

    runs-on: ${{ matrix.platform }}
    defaults:
      run:
        working-directory: app

    outputs:
      version: ${{ steps.get_version.outputs.version }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get version from tag
        id: get_version
        shell: bash
        run: |
          if [[ "${{ github.ref_type }}" == "tag" ]]; then
            VERSION="${{ github.ref_name }}"
            VERSION="${VERSION#v}"  # Remove 'v' prefix
          else
            VERSION="0.0.0-dev"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

      # -------------------------------------------------------------------------
      # Platform-specific dependencies
      # -------------------------------------------------------------------------
      - name: Install dependencies (Ubuntu)
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            libappindicator3-dev \
            librsvg2-dev \
            patchelf \
            libssl-dev

      # -------------------------------------------------------------------------
      # Setup build tools
      # -------------------------------------------------------------------------
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "pnpm"
          cache-dependency-path: app/pnpm-lock.yaml

      - name: Install Rust stable
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Setup Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: "app/src-tauri -> target"
          shared-key: ${{ matrix.target }}

      - name: Install frontend dependencies
        run: pnpm install --frozen-lockfile

      # -------------------------------------------------------------------------
      # Download FFmpeg binaries
      # -------------------------------------------------------------------------
      - name: Download FFmpeg (macOS)
        if: matrix.platform == 'macos-latest'
        run: |
          chmod +x src-tauri/scripts/download-ffmpeg.sh
          src-tauri/scripts/download-ffmpeg.sh ${{ matrix.ffmpeg_target }}

      - name: Download FFmpeg (Linux)
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          chmod +x src-tauri/scripts/download-ffmpeg.sh
          src-tauri/scripts/download-ffmpeg.sh ${{ matrix.ffmpeg_target }}

      - name: Download FFmpeg (Windows)
        if: matrix.platform == 'windows-latest'
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path src-tauri/binaries
          Invoke-WebRequest -Uri "https://www.gyan.dev/ffmpeg/builds/ffmpeg-release-essentials.zip" -OutFile "$env:TEMP\ffmpeg-win.zip"
          Expand-Archive -Path "$env:TEMP\ffmpeg-win.zip" -DestinationPath "$env:TEMP\ffmpeg-win" -Force
          $binDir = Get-ChildItem -Path "$env:TEMP\ffmpeg-win" -Directory | Select-Object -First 1
          Copy-Item "$($binDir.FullName)\bin\ffmpeg.exe" -Destination "src-tauri/binaries/ffmpeg-x86_64-pc-windows-msvc.exe"
          Copy-Item "$($binDir.FullName)\bin\ffprobe.exe" -Destination "src-tauri/binaries/ffprobe-x86_64-pc-windows-msvc.exe"
          Get-ChildItem src-tauri/binaries/

      # -------------------------------------------------------------------------
      # macOS Code Signing Setup
      # -------------------------------------------------------------------------
      - name: Setup macOS code signing
        if: matrix.platform == 'macos-latest'
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          # Create temporary keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

          # Create keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Import certificate
          echo "$APPLE_CERTIFICATE" | base64 --decode > $RUNNER_TEMP/certificate.p12
          security import $RUNNER_TEMP/certificate.p12 \
            -P "$APPLE_CERTIFICATE_PASSWORD" \
            -A \
            -t cert \
            -f pkcs12 \
            -k "$KEYCHAIN_PATH"

          # Set key partition list for codesign access
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Add keychain to search list
          security list-keychain -d user -s "$KEYCHAIN_PATH" login.keychain

          # Verify certificate
          security find-identity -v -p codesigning "$KEYCHAIN_PATH"

      - name: Select Xcode (macOS)
        if: matrix.platform == 'macos-latest'
        run: sudo xcode-select -s /Applications/Xcode.app/Contents/Developer

      # -------------------------------------------------------------------------
      # Build Tauri App
      # -------------------------------------------------------------------------
      - name: Build Tauri app
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # Tauri updater signing
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          # Apple signing (macOS only)
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        with:
          args: --target ${{ matrix.target }} --bundles ${{ matrix.bundle_targets }}
          tauriScript: pnpm tauri

      # -------------------------------------------------------------------------
      # Collect and upload artifacts
      # -------------------------------------------------------------------------
      - name: Collect build artifacts (macOS)
        if: matrix.platform == 'macos-latest'
        shell: bash
        run: |
          mkdir -p ../artifacts/installers
          mkdir -p ../artifacts/updates

          TARGET_DIR="src-tauri/target/${{ matrix.target }}/release/bundle"
          VERSION="${{ steps.get_version.outputs.version }}"
          PLATFORM="${{ matrix.os }}-${{ matrix.arch }}"

          echo "=== Listing all bundle contents ==="
          find "$TARGET_DIR" -type f 2>/dev/null || echo "No files found in bundle directory"

          # DMG installer - find it dynamically
          DMG_FILE=$(find "$TARGET_DIR/dmg" -name "*.dmg" -type f 2>/dev/null | head -1)
          if [ -n "$DMG_FILE" ] && [ -f "$DMG_FILE" ]; then
            cp "$DMG_FILE" "../artifacts/installers/Rigid_${VERSION}_${PLATFORM}.dmg"
            echo "Found DMG installer: $DMG_FILE"
          else
            echo "Warning: No DMG found in $TARGET_DIR/dmg"
            ls -la "$TARGET_DIR/dmg" 2>/dev/null || echo "dmg directory not found"
          fi

          # Update bundle (.app.tar.gz and .app.tar.gz.sig)
          # Tauri v2 puts these in the macos directory
          UPDATE_FILE=$(find "$TARGET_DIR/macos" -name "*.app.tar.gz" -type f 2>/dev/null | head -1)
          if [ -n "$UPDATE_FILE" ] && [ -f "$UPDATE_FILE" ]; then
            cp "$UPDATE_FILE" "../artifacts/updates/Rigid_${VERSION}_${PLATFORM}.app.tar.gz"
            echo "Found update bundle: $UPDATE_FILE"
          else
            echo "Warning: No .app.tar.gz found in $TARGET_DIR/macos"
            echo "Contents of macos directory:"
            ls -la "$TARGET_DIR/macos" 2>/dev/null || echo "macos directory not found"
          fi

          SIG_FILE=$(find "$TARGET_DIR/macos" -name "*.app.tar.gz.sig" -type f 2>/dev/null | head -1)
          if [ -n "$SIG_FILE" ] && [ -f "$SIG_FILE" ]; then
            cp "$SIG_FILE" "../artifacts/updates/Rigid_${VERSION}_${PLATFORM}.app.tar.gz.sig"
            echo "Found update signature: $SIG_FILE"
          else
            echo "Warning: No .app.tar.gz.sig found"
          fi

          echo "=== Collected artifacts ==="
          ls -la ../artifacts/installers/ || true
          ls -la ../artifacts/updates/ || true

      - name: Collect build artifacts (Linux)
        if: matrix.platform == 'ubuntu-22.04'
        shell: bash
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: |
          mkdir -p ../artifacts/installers
          mkdir -p ../artifacts/updates

          TARGET_DIR="src-tauri/target/${{ matrix.target }}/release/bundle"
          VERSION="${{ steps.get_version.outputs.version }}"
          PLATFORM="${{ matrix.os }}-${{ matrix.arch }}"

          echo "=== Listing all bundle contents ==="
          find "$TARGET_DIR" -type f 2>/dev/null || echo "No files found in bundle directory"

          # AppImage installer
          APPIMAGE=$(find "$TARGET_DIR/appimage" -name "*.AppImage" -not -name "*.sig" -type f 2>/dev/null | head -1)
          if [ -n "$APPIMAGE" ] && [ -f "$APPIMAGE" ]; then
            cp "$APPIMAGE" "../artifacts/installers/Rigid_${VERSION}_${PLATFORM}.AppImage"
            echo "Found AppImage installer: $APPIMAGE"
          else
            echo "Warning: No AppImage found"
          fi

          # Deb installer
          if ls $TARGET_DIR/deb/*.deb 1> /dev/null 2>&1; then
            cp $TARGET_DIR/deb/*.deb ../artifacts/installers/
            echo "Found Deb installer"
          fi

          # Update bundle - Tauri doesn't create .tar.gz for AppImage by default
          # We need to create it manually and sign it
          if [ -n "$APPIMAGE" ] && [ -f "$APPIMAGE" ]; then
            APPIMAGE_NAME=$(basename "$APPIMAGE")
            TARBALL="../artifacts/updates/Rigid_${VERSION}_${PLATFORM}.AppImage.tar.gz"

            echo "Creating tar.gz archive of AppImage..."
            tar -czvf "$TARBALL" -C "$(dirname "$APPIMAGE")" "$APPIMAGE_NAME"

            # Sign the tarball
            echo "Signing the tarball..."
            if [ -n "$TAURI_SIGNING_PRIVATE_KEY_PASSWORD" ]; then
              npx --yes @tauri-apps/cli signer sign -k "$TAURI_SIGNING_PRIVATE_KEY" -p "$TAURI_SIGNING_PRIVATE_KEY_PASSWORD" "$TARBALL"
            else
              npx --yes @tauri-apps/cli signer sign -k "$TAURI_SIGNING_PRIVATE_KEY" "$TARBALL"
            fi

            if [ -f "${TARBALL}.sig" ]; then
              echo "Successfully created and signed update bundle: $TARBALL"
              ls -la "${TARBALL}"*
            else
              echo "ERROR: Failed to sign tarball"
              exit 1
            fi
          else
            echo "ERROR: No AppImage found to create update bundle"
            exit 1
          fi

          echo "=== Collected artifacts ==="
          ls -la ../artifacts/installers/ || true
          ls -la ../artifacts/updates/ || true

      - name: Collect build artifacts (Windows)
        if: matrix.platform == 'windows-latest'
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path ../artifacts/installers
          New-Item -ItemType Directory -Force -Path ../artifacts/updates

          $targetDir = "src-tauri/target/${{ matrix.target }}/release/bundle"
          $version = "${{ steps.get_version.outputs.version }}"
          $platform = "${{ matrix.os }}-${{ matrix.arch }}"

          Write-Host "=== Listing all bundle contents ==="
          Get-ChildItem -Path $targetDir -Recurse -File -ErrorAction SilentlyContinue | ForEach-Object { Write-Host $_.FullName }

          # NSIS installer (.exe)
          $nsisPath = Get-ChildItem -Path "$targetDir/nsis" -Filter "*.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($nsisPath) {
            Copy-Item $nsisPath.FullName -Destination "../artifacts/installers/Rigid_${version}_${platform}-setup.exe"
            Write-Host "Found NSIS installer: $($nsisPath.FullName)"
          } else {
            Write-Host "Warning: No .exe found in $targetDir/nsis"
          }

          # Update bundle (.nsis.zip and .nsis.zip.sig)
          $updateZip = Get-ChildItem -Path "$targetDir/nsis" -Filter "*.nsis.zip" -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($updateZip) {
            Copy-Item $updateZip.FullName -Destination "../artifacts/updates/Rigid_${version}_${platform}.nsis.zip"
            Write-Host "Found update zip: $($updateZip.FullName)"
          } else {
            Write-Host "Warning: No .nsis.zip found in $targetDir/nsis"
            Write-Host "Contents of nsis directory:"
            Get-ChildItem -Path "$targetDir/nsis" -ErrorAction SilentlyContinue | ForEach-Object { Write-Host $_.Name }
          }

          $updateSig = Get-ChildItem -Path "$targetDir/nsis" -Filter "*.nsis.zip.sig" -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($updateSig) {
            Copy-Item $updateSig.FullName -Destination "../artifacts/updates/Rigid_${version}_${platform}.nsis.zip.sig"
            Write-Host "Found update signature: $($updateSig.FullName)"
          } else {
            Write-Host "Warning: No .nsis.zip.sig found"
          }

          Write-Host "=== Collected artifacts ==="
          Get-ChildItem ../artifacts/installers/ -ErrorAction SilentlyContinue
          Get-ChildItem ../artifacts/updates/ -ErrorAction SilentlyContinue

      - name: Upload installer artifacts
        uses: actions/upload-artifact@v4
        with:
          name: installers-${{ matrix.target }}
          path: artifacts/installers/*
          if-no-files-found: warn
          retention-days: 7

      - name: Upload update artifacts
        uses: actions/upload-artifact@v4
        with:
          name: updates-${{ matrix.target }}
          path: artifacts/updates/*
          if-no-files-found: warn
          retention-days: 7

  # ===========================================================================
  # Upload and Register - uploads to R2 and registers with Oasis
  # ===========================================================================
  upload-and-register:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref_type == 'tag' && !inputs.dry_run

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get version from tag
        id: get_version
        run: |
          VERSION="${{ github.ref_name }}"
          VERSION="${VERSION#v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

      - name: Download all installer artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: installers-*
          path: artifacts/installers
          merge-multiple: true

      - name: Download all update artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: updates-*
          path: artifacts/updates
          merge-multiple: true

      - name: Display downloaded artifacts
        run: |
          echo "=== Installers ==="
          ls -la artifacts/installers/ || echo "No installers found"
          echo ""
          echo "=== Updates ==="
          ls -la artifacts/updates/ || echo "No updates found"

      # -------------------------------------------------------------------------
      # Upload to Cloudflare R2
      # -------------------------------------------------------------------------
      - name: Setup rclone for R2
        run: |
          curl -O https://downloads.rclone.org/rclone-current-linux-amd64.deb
          sudo dpkg -i rclone-current-linux-amd64.deb

          # Configure rclone for Cloudflare R2
          mkdir -p ~/.config/rclone
          echo "[r2]" > ~/.config/rclone/rclone.conf
          echo "type = s3" >> ~/.config/rclone/rclone.conf
          echo "provider = Cloudflare" >> ~/.config/rclone/rclone.conf
          echo "access_key_id = ${{ secrets.CLOUDFLARE_R2_ACCESS_KEY_ID }}" >> ~/.config/rclone/rclone.conf
          echo "secret_access_key = ${{ secrets.CLOUDFLARE_R2_SECRET_ACCESS_KEY }}" >> ~/.config/rclone/rclone.conf
          echo "endpoint = https://${{ secrets.CLOUDFLARE_ACCOUNT_ID }}.r2.cloudflarestorage.com" >> ~/.config/rclone/rclone.conf
          echo "acl = private" >> ~/.config/rclone/rclone.conf
          echo "no_check_bucket = true" >> ~/.config/rclone/rclone.conf

      - name: Upload installers to R2
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          BUCKET="${{ secrets.R2_BUCKET_NAME }}"

          echo "=== Uploading Installers ==="
          if [ -d "artifacts/installers" ] && [ "$(ls -A artifacts/installers 2>/dev/null)" ]; then
            for file in artifacts/installers/*; do
              if [ -f "$file" ]; then
                FILENAME=$(basename "$file")
                R2_KEY="${{ env.APP_SLUG }}/installers/$VERSION/$FILENAME"
                echo "Uploading $FILENAME to r2:$BUCKET/$R2_KEY"
                rclone copyto "$file" "r2:$BUCKET/$R2_KEY"
                echo "Uploaded: $R2_KEY"
              fi
            done
          else
            echo "No installers to upload"
          fi

      - name: Upload updates to R2
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          BUCKET="${{ secrets.R2_BUCKET_NAME }}"

          echo "=== Uploading Update Artifacts ==="
          if [ -d "artifacts/updates" ] && [ "$(ls -A artifacts/updates 2>/dev/null)" ]; then
            for file in artifacts/updates/*; do
              if [ -f "$file" ]; then
                FILENAME=$(basename "$file")
                R2_KEY="${{ env.APP_SLUG }}/releases/$VERSION/$FILENAME"
                echo "Uploading $FILENAME to r2:$BUCKET/$R2_KEY"
                rclone copyto "$file" "r2:$BUCKET/$R2_KEY"
                echo "Uploaded: $R2_KEY"
              fi
            done
          else
            echo "No updates to upload"
          fi

      # -------------------------------------------------------------------------
      # Register release with Oasis
      # -------------------------------------------------------------------------
      - name: Register release with Oasis
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"

          # Build artifacts array for Oasis API
          ARTIFACTS="["
          FIRST=true

          # Process each platform for update artifacts
          for platform in "darwin-aarch64" "darwin-x86_64" "linux-x86_64" "windows-x86_64"; do
            OS=$(echo $platform | cut -d'-' -f1)

            # Determine file extension based on platform
            if [[ "$OS" == "darwin" ]]; then
              EXT=".app.tar.gz"
            elif [[ "$OS" == "linux" ]]; then
              EXT=".AppImage.tar.gz"
            elif [[ "$OS" == "windows" ]]; then
              EXT=".nsis.zip"
            fi

            ARTIFACT_FILE="artifacts/updates/Rigid_${VERSION}_${platform}${EXT}"
            SIG_FILE="${ARTIFACT_FILE}.sig"

            if [ -f "$ARTIFACT_FILE" ] && [ -f "$SIG_FILE" ]; then
              SIGNATURE=$(cat "$SIG_FILE")
              R2_KEY="${{ env.APP_SLUG }}/releases/$VERSION/Rigid_${VERSION}_${platform}${EXT}"

              if [ "$FIRST" = true ]; then
                FIRST=false
              else
                ARTIFACTS="$ARTIFACTS,"
              fi

              ARTIFACTS="$ARTIFACTS{\"platform\":\"$platform\",\"signature\":\"$SIGNATURE\",\"r2_key\":\"$R2_KEY\"}"
              echo "Added artifact for $platform"
            else
              echo "Warning: Missing artifact or signature for $platform"
            fi
          done

          ARTIFACTS="$ARTIFACTS]"

          # Build installers array for Oasis API
          INSTALLERS="["
          FIRST_INSTALLER=true

          # Process installers for each platform
          declare -A INSTALLER_DISPLAY_NAMES
          INSTALLER_DISPLAY_NAMES["darwin-aarch64"]="macOS (Apple Silicon)"
          INSTALLER_DISPLAY_NAMES["darwin-x86_64"]="macOS (Intel)"
          INSTALLER_DISPLAY_NAMES["windows-x86_64"]="Windows (64-bit)"
          INSTALLER_DISPLAY_NAMES["linux-x86_64"]="Linux (64-bit)"

          for platform in "darwin-aarch64" "darwin-x86_64" "windows-x86_64" "linux-x86_64"; do
            OS=$(echo $platform | cut -d'-' -f1)

            # Determine installer file pattern based on platform
            if [[ "$OS" == "darwin" ]]; then
              INSTALLER_FILE="artifacts/installers/Rigid_${VERSION}_${platform}.dmg"
            elif [[ "$OS" == "windows" ]]; then
              INSTALLER_FILE="artifacts/installers/Rigid_${VERSION}_${platform}-setup.exe"
            elif [[ "$OS" == "linux" ]]; then
              INSTALLER_FILE="artifacts/installers/Rigid_${VERSION}_${platform}.AppImage"
            fi

            if [ -f "$INSTALLER_FILE" ]; then
              FILENAME=$(basename "$INSTALLER_FILE")
              R2_KEY="${{ env.APP_SLUG }}/installers/$VERSION/$FILENAME"
              DISPLAY_NAME="${INSTALLER_DISPLAY_NAMES[$platform]:-$platform}"

              if [ "$FIRST_INSTALLER" = true ]; then
                FIRST_INSTALLER=false
              else
                INSTALLERS="$INSTALLERS,"
              fi

              INSTALLERS="$INSTALLERS{\"platform\":\"$platform\",\"filename\":\"$FILENAME\",\"r2_key\":\"$R2_KEY\",\"display_name\":\"$DISPLAY_NAME\"}"
              echo "Added installer for $platform: $FILENAME"
            else
              echo "No installer found for $platform (optional)"
            fi
          done

          INSTALLERS="$INSTALLERS]"

          # Build release notes from tag message or default
          NOTES="Release v$VERSION"
          if [ -n "${{ github.event.head_commit.message }}" ]; then
            NOTES="${{ github.event.head_commit.message }}"
          fi

          # Create the API payload using jq with --arg for proper escaping
          PAYLOAD=$(jq -n \
            --arg version "$VERSION" \
            --arg notes "$NOTES" \
            --argjson artifacts "$ARTIFACTS" \
            --argjson installers "$INSTALLERS" \
            '{
              version: $version,
              notes: $notes,
              artifacts: $artifacts,
              installers: $installers,
              auto_publish: false
            }')

          echo "Registering release with Oasis server..."
          echo "Payload:"
          echo "$PAYLOAD" | jq .

          # Make the API call to the correct endpoint
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            "${{ secrets.OASIS_SERVER_URL }}/ci/apps/${{ env.APP_SLUG }}/releases" \
            -H "Authorization: Bearer ${{ secrets.OASIS_CI_KEY }}" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD")

          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          BODY=$(echo "$RESPONSE" | head -n -1)

          echo "Response code: $HTTP_CODE"
          echo "Response body: $BODY"

          if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
            echo "Failed to register release with Oasis server"
            exit 1
          fi

          echo "Successfully registered release $VERSION with Oasis server"

  # ===========================================================================
  # Create GitHub Release
  # ===========================================================================
  github-release:
    needs: [build, upload-and-register]
    runs-on: ubuntu-latest
    if: github.ref_type == 'tag'
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get version from tag
        id: get_version
        run: |
          VERSION="${{ github.ref_name }}"
          VERSION="${VERSION#v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Download all installer artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: installers-*
          path: release-assets
          merge-multiple: true

      - name: Generate release notes
        id: release_notes
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          R2_URL="${{ secrets.R2_PUBLIC_URL }}"

          cat > RELEASE_NOTES.md << 'EOF'
          ## Downloads

          ### macOS
          - [Rigid_VERSION_darwin-aarch64.dmg](R2_URL/APP_SLUG/installers/VERSION/Rigid_VERSION_darwin-aarch64.dmg) - Apple Silicon (M1/M2/M3)
          - [Rigid_VERSION_darwin-x86_64.dmg](R2_URL/APP_SLUG/installers/VERSION/Rigid_VERSION_darwin-x86_64.dmg) - Intel

          ### Windows
          - [Rigid_VERSION_windows-x86_64-setup.exe](R2_URL/APP_SLUG/installers/VERSION/Rigid_VERSION_windows-x86_64-setup.exe) - Windows 64-bit

          ### Linux
          - [Rigid_VERSION_linux-x86_64.AppImage](R2_URL/APP_SLUG/installers/VERSION/Rigid_VERSION_linux-x86_64.AppImage) - AppImage (Universal)

          ---

          ## Auto-Updates

          This release supports automatic updates. If you have a previous version installed, you will be prompted to update automatically.

          ## Checksums

          See the attached `checksums.txt` file for SHA256 checksums of all artifacts.
          EOF

          # Replace placeholders
          sed -i "s/VERSION/$VERSION/g" RELEASE_NOTES.md
          sed -i "s|R2_URL|$R2_URL|g" RELEASE_NOTES.md
          sed -i "s/APP_SLUG/${{ env.APP_SLUG }}/g" RELEASE_NOTES.md

          cat RELEASE_NOTES.md

      - name: Generate checksums
        run: |
          cd release-assets
          sha256sum * > checksums.txt || true
          cat checksums.txt

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          name: "Rigid v${{ steps.get_version.outputs.version }}"
          body_path: RELEASE_NOTES.md
          draft: false
          prerelease: ${{ contains(github.ref_name, '-') }}
          files: |
            release-assets/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ===========================================================================
  # Cleanup on failure
  # ===========================================================================
  cleanup-on-failure:
    needs: [build, upload-and-register, github-release]
    runs-on: ubuntu-latest
    if: failure() && github.ref_type == 'tag'

    steps:
      - name: Notify failure
        run: |
          echo "Release workflow failed for version ${{ github.ref_name }}"
          echo "Please check the logs and retry if necessary."
          # Add notification integration here (Slack, Discord, email, etc.)

      - name: Cleanup partial R2 uploads (optional)
        if: false  # Enable if you want automatic cleanup
        run: |
          # This step can be used to clean up partial uploads
          # Be careful with this - you may want to keep partial uploads for debugging
          echo "Cleanup disabled - manual intervention may be required"
